- 系统调用是操作系统内核暴露的一组接口函数，用户封装硬件，内核数据等。可以保证系统的安全和稳定
  `printf` `read` `open` 都是常用的系统调用函数
- 上一个实验 [[Lab1: xv6 和 Unix 工具]] 已经使用 system calls 来实现了一些工具，这个实验将增加一些新的 system calls
- 如何切换到内核态？
  - 1. 触发软件中断
  - 2. cpu 切换到内核态
  - 3. 根据系统调用号确定执行的服务，完成后将结果或者错误码存入用户程序的寄存器，并返回用户态继续执行
- 
- 涉及的文件：
  - `user/user.h` -> 用户态程序调班函数
  - `user/usys.pl` -> 跳板函数使用 CPU 提供的 ecall 指令，切换到**内核态**
  - `kernel/syscall.c` -> 内核态下系统调用处理函数 `syscall()`，所有的系统调用都在这
  - `kernel/syscall.h` -> 设定系统调用号
- 
- **相关知识**
  - {{embed ((68c35cbe-42aa-4db0-bbce-309a316c2583))}}
# System call tracing
- `moderate`
- > 增加一个系统调用来追踪特征，trace 系统调用需要一个参数 mask，例如 trace (1 << 5) 指的是追踪系统调用号为 5 的系统调用
- 
- 
- 这个 lab 比较简单，详细内容暂不记录
